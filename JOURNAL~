Introduction
The purpose of this assignment is to evaluate your ability to work with programming tasks that resemble the day-to-day activities of the Kanzi R&D team at Rightware. This assignment focuses on C++ programming and general middleware development practices.

Kanzi R&D lists following characteristics valuable in written code and you should keep them in mind while working on the assignment. Both code and documentation quality will be evaluated.

 Safety
 Modularity
 Efficiency
 Readability & Maintainability
 Reliability & Simplicity

Instructions

- Write a C++ class, which can be used to output application log messages to multiple outputs
- Focus both on the quality of the code and to the usability of the class (API).

- Send your solution to Rightware in a ZIP package containing the following contents:
	o source code, solution and project files
	o executable that is outputting log messages
	o instructionshowtocompile
	o list of 3rd party dependencies, if any
	o brief description of the work sample including rationale behind the implementation, as well
	as its possible shortcomings and known issues o ideas for further development

Requirements
	- Implementation language is C++ (with C++11 features available)
	- The logger needs to support multiple threads
	- The logger needs to be able to support multiple outputs (file, console etc.)
	- The logger needs to be able to support outputting user types
	- The logger class API needs to be documented and validated with unit test(s)
	- The executable code should work either on Windows (preferred), Mac OS X or Linux

Fri Apr  6 11:34:40 EEST 2018
============================

So.

We need to create a logger class.

A logger needs to logs things.

So, how would we use this thing ?

unique_ptr<Logger> logger = make_unique<Logger()>;

C++11 features.
Does C++11 have make unique ?
Yes.

Let's use smart pointers, just because we can, and it's much easier to maintain.

// What options do we need to set with the logger ?

// Output destination
// Input

Should we do ?

logger << "This is our log message";

Nah we don't want to do << operator overloading, it requires too much complex changes, and also prevents us from using this logger interface outside C++ easily.

// Where are we outputting ?
// File, console, possibly network
// Let's implement file and console for now, but take into account that it might be something generalized we need to implement

// How would we set the output ? Ideally the logger class would not contain any information about how the messages are actually stored
// It could just let a LoggerOutput class handle the actual storage of the messages

// This way you can implement for example FileOutput, ConsoleOutput, NetworkOutput classes that extend from the LoggerOutput class
// and implement the actual storage and required details there like mutex locking ?

// We should just set the path to which we want to log to
// The logger parses a path
// Then based on the path, decides which internal output class to use for the actual outputting
// So actually we implement the outputter inside the logger, so that the caller doesn't also have
// to care about the output class or ownership of that

// Make it easy to use, and natural, no need to figure out some ENUMS or combinations of types and strings,  
// just define a clear set of output path options for the user, and document how they work
// This way the logger can also be extended easily, just add more path types and internal output classes inside the logger
// The external API stays the same, only the internal implementation changes

unique_ptr<Logger> logger = make_unique<Logger()>;
if (logger) {
	logger->set_log_level(Logger::MSG || Logger::INFO || Logger::WARN);

	//logger->set_output_path("console");
	//logger->set_output_path("https://localhost.dev:3000/log");
	logger->set_output_path("/tmp/test_log_01.txt");
}

logger->log(Logger::INFO, "All systems initialized");
logger->log(Logger::CMD, "Set warp speed to 7");

It should be this easy. We create the logger, we set the log level that we are outputting messages at, and we set the output class that will handle the outputting of the messages.

We need to be able to output user types ? What does this mean ?
I guess you would need to be able to output custom types.

So basically we have some custom user types and you would need to be able to output those.
I guess those types would have some sort of output method within them that knows how to convert them to strings or serialize them.

// We assume our user type classes can implement a method to convert them to strings
class UserType {
	public:
		std::wstring to_string();
};

We don't want to start overloading operators here, that just adds complexity and unknown factors.
Let's be functional and simple.

How about multithreading ?
What would this mean ?

I guess it means the output to the same output from different threads should be somehow mutex locked.
